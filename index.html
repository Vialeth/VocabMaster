<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabMaster AI</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        gray: {
                            750: '#2d3748',
                            850: '#1a202c',
                            950: '#0d1117',
                        }
                    }
                }
            }
        }
    </script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; transition: background-color 0.3s ease; }
        body { background-color: #f3f4f6; }
        .dark body { background-color: #111827; }

        .card-shadow { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .dark .card-shadow { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2); }

        .glass-effect { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }

        .loading-dots:after { content: ' .'; animation: dots 1s steps(5, end) infinite;}
        @keyframes dots { 0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 40% { color: #333; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 60% { text-shadow: .25em 0 0 #333, .5em 0 0 rgba(0,0,0,0);} 80%, 100% { text-shadow: .25em 0 0 #333, .5em 0 0 #333;}}
        .dark .loading-dots:after { animation: dotsDark 1s steps(5, end) infinite;}
        @keyframes dotsDark { 0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 40% { color: #ccc; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 60% { text-shadow: .25em 0 0 #ccc, .5em 0 0 rgba(0,0,0,0);} 80%, 100% { text-shadow: .25em 0 0 #ccc, .5em 0 0 #ccc;}}
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS ---
        const PlusIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" /></svg>);
        const TrashIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
        const BrainIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>);
        const ListIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>);
        const SparklesIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" /></svg>);
        const SettingsIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
        const BulbIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>);
        const MoonIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>);
        const SunIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>);
        const GlobeIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
        const ChevronDown = () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7" /></svg>);
        const ShuffleIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>);
        const GridIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>);
        const ArrowLeftIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>);
        const EyeIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>);
        const EyeOffIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" /></svg>);
        const RefreshIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>);
        const ChevronLeftIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" /></svg>);
        const ChevronRightIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" /></svg>);
        const DownloadIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>);
        const UploadIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>);
        const InfoIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);

        // --- GEMINI API HELPER ---
        const callGeminiAPI = async (prompt, userKey) => {
            const envKey = "";
            const apiKey = userKey || envKey;

            if (!apiKey) {
                throw new Error("Please enter an API Key in Settings.");
            }

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }]
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || "API Error");
            }

            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "No result found.";
        };

        function App() {
            // --- STATE MANAGEMENT ---

            // Decks
            const [decks, setDecks] = useState(() => {
                const savedNew = localStorage.getItem('vocabMaster_decks');
                let initialDecks = [];
                if (savedNew) {
                    initialDecks = JSON.parse(savedNew);
                } else {
                    const savedOld = localStorage.getItem('myVocabApp_words');
                    if (savedOld) {
                        const oldWords = JSON.parse(savedOld);
                        initialDecks = [{
                            id: 'default',
                            sourceLang: 'English',
                            targetLang: 'Turkish',
                            words: oldWords
                        }];
                    } else {
                        initialDecks = [{
                            id: 'default',
                            sourceLang: 'English',
                            targetLang: 'Turkish',
                            words: []
                        }];
                    }
                }

                // MIGRATION: Ensure all words have 'examples' array
                return initialDecks.map(d => ({
                    ...d,
                    words: d.words.map(w => ({
                        ...w,
                        examples: w.examples || [] // Initialize if missing
                    }))
                }));
            });

            const [activeDeckId, setActiveDeckId] = useState(() => localStorage.getItem('vocabMaster_activeDeck') || 'default');
            const activeDeck = decks.find(d => d.id === activeDeckId) || decks[0];

            const [view, setView] = useState('list');
            const [newWord, setNewWord] = useState('');
            const [newMeaning, setNewMeaning] = useState('');
            const [contextHint, setContextHint] = useState(null);

            // All Words View States
            const [shuffledWords, setShuffledWords] = useState([]);
            const [isStudyMode, setIsStudyMode] = useState(false);
            const [revealedCards, setRevealedCards] = useState({}); // { [id]: boolean }
            const [revealedSentences, setRevealedSentences] = useState({}); // { [id]: boolean }

            // Navigation state for examples: { [wordId]: currentExampleIndex }
            const [activeExampleIndices, setActiveExampleIndices] = useState({});

            // UI States
            const [showSettings, setShowSettings] = useState(false);
            const [showDeckModal, setShowDeckModal] = useState(false);
            const [showDeckSelector, setShowDeckSelector] = useState(false);

            // New Deck Form
            const [newSourceLang, setNewSourceLang] = useState('');
            const [newTargetLang, setNewTargetLang] = useState('');

            // API & Dark Mode
            const [userApiKey, setUserApiKey] = useState(() => localStorage.getItem('gemini_user_key') || '');
            const [darkMode, setDarkMode] = useState(() => {
                if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    return true;
                }
                return false;
            });

            // AI Loading States
            const [isAutoDefining, setIsAutoDefining] = useState(false);
            const [generatingSentenceFor, setGeneratingSentenceFor] = useState(null);

            // Quiz State
            const [currentQuestion, setCurrentQuestion] = useState(null);
            const [selectedOption, setSelectedOption] = useState(null);
            const [isCorrect, setIsCorrect] = useState(null);
            const [streak, setStreak] = useState(0);

            // Import File Reference
            const fileInputRef = useRef(null);

            // --- EFFECTS ---
            useEffect(() => { localStorage.setItem('vocabMaster_decks', JSON.stringify(decks)); }, [decks]);
            useEffect(() => { localStorage.setItem('vocabMaster_activeDeck', activeDeckId); }, [activeDeckId]);
            useEffect(() => { localStorage.setItem('gemini_user_key', userApiKey); }, [userApiKey]);
            useEffect(() => {
                if (darkMode) {
                    document.documentElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            }, [darkMode]);

            useEffect(() => {
                if (view === 'allWords') {
                    setShuffledWords([...activeDeck.words].reverse());
                    setRevealedCards({}); // Reset reveals on enter
                    setRevealedSentences({});
                }
            }, [view, activeDeck.words]);

            // --- DATA MANAGEMENT ---
            const handleExport = () => {
                const dataStr = JSON.stringify(decks, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = "vocabmaster_backup.json";
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedDecks = JSON.parse(e.target.result);
                        if (Array.isArray(importedDecks)) {
                            setDecks(importedDecks);
                            alert("Data imported successfully!");
                            // If current active deck doesn't exist in new data, reset to first
                            if (!importedDecks.find(d => d.id === activeDeckId)) {
                                setActiveDeckId(importedDecks[0]?.id || 'default');
                            }
                        } else {
                            alert("Invalid file format.");
                        }
                    } catch (error) {
                        alert("Error importing file: " + error.message);
                    }
                };
                reader.readAsText(file);
                // Reset input
                event.target.value = null;
            };

            // --- DECK MANAGEMENT ---
            const handleCreateDeck = (e) => {
                e.preventDefault();
                if (!newSourceLang.trim() || !newTargetLang.trim()) return;
                const newDeck = {
                    id: Date.now().toString(),
                    sourceLang: capitalizeFirst(newSourceLang.trim()),
                    targetLang: capitalizeFirst(newTargetLang.trim()),
                    words: []
                };
                setDecks([...decks, newDeck]);
                setActiveDeckId(newDeck.id);
                setNewSourceLang('');
                setNewTargetLang('');
                setShowDeckModal(false);
            };

            const switchDeck = (id) => {
                setActiveDeckId(id);
                setShowDeckSelector(false);
                setNewWord('');
                setNewMeaning('');
                setContextHint(null);
                setStreak(0);
                setCurrentQuestion(null);
            };

            // --- WORD MANAGEMENT ---
            const capitalizeFirst = (str) => {
                if (!str) return '';
                return str.charAt(0).toUpperCase() + str.slice(1);
            };

            const handleAddWord = (e) => {
                e.preventDefault();
                if (!newWord.trim() || !newMeaning.trim()) return;
                const newItem = {
                    id: Date.now(),
                    word: capitalizeFirst(newWord.trim()),
                    meaning: capitalizeFirst(newMeaning.trim()), // Just saves clean meaning text
                    examples: []
                };
                const updatedDecks = decks.map(deck => {
                    if (deck.id === activeDeckId) {
                        return { ...deck, words: [newItem, ...deck.words] };
                    }
                    return deck;
                });
                setDecks(updatedDecks);
                setNewWord('');
                setNewMeaning('');
                setContextHint(null); // Reset hint
            };

            const handleDelete = (id) => {
                if (confirm('Are you sure you want to delete this word?')) {
                    const updatedDecks = decks.map(deck => {
                        if (deck.id === activeDeckId) {
                            return { ...deck, words: deck.words.filter(w => w.id !== id) };
                        }
                        return deck;
                    });
                    setDecks(updatedDecks);
                }
            };

            const handleShuffle = () => {
                setShuffledWords(prev => [...prev].sort(() => Math.random() - 0.5));
            };

            const toggleStudyMode = () => {
                setIsStudyMode(!isStudyMode);
                setRevealedCards({});
                setRevealedSentences({});
            };

            const toggleReveal = (id) => {
                if (isStudyMode) {
                    setRevealedCards(prev => ({ ...prev, [id]: !prev[id] }));
                }
            };

            const handlePrevExample = (wordId, total) => {
                setActiveExampleIndices(prev => {
                    const current = prev[wordId] !== undefined ? prev[wordId] : total - 1;
                    const next = current > 0 ? current - 1 : current;
                    return { ...prev, [wordId]: next };
                });
            };

            const handleNextExample = (wordId, total) => {
                setActiveExampleIndices(prev => {
                    const current = prev[wordId] !== undefined ? prev[wordId] : total - 1;
                    const next = current < total - 1 ? current + 1 : current;
                    return { ...prev, [wordId]: next };
                });
            };

            const renderMeaningHTML = (text, isQuiz = false) => {
                if (!text) return null;
                return text;
            };

            const renderGeneratedSentence = (id, text) => {
                if (!isStudyMode) return text;

                const lastParenIndex = text.lastIndexOf('(');
                if (lastParenIndex === -1) return text;

                const sentenceText = text.substring(0, lastParenIndex);
                const translationText = text.substring(lastParenIndex);
                const isRevealed = revealedSentences[id];

                return (
                    <span>
                        {sentenceText}
                        <span
                            onClick={(e) => {
                                e.stopPropagation();
                                setRevealedSentences(prev => ({...prev, [id]: !prev[id]}));
                            }}
                            className={`cursor-pointer rounded px-1 transition-all ${isRevealed ? 'text-indigo-800 dark:text-indigo-200' : 'bg-indigo-200 dark:bg-indigo-700 text-transparent select-none'}`}
                        >
                            {translationText}
                        </span>
                    </span>
                );
            };

            const checkWord = newWord.trim();
            const bracketMatch = checkWord.match(/\[(.*?)\]/);
            const wordToSearch = bracketMatch ? bracketMatch[1] : checkWord;
            const existingWordMatch = wordToSearch
                ? activeDeck.words.find(w => w.word.toLowerCase() === wordToSearch.trim().toLowerCase())
                : null;

            // --- AI FEATURES ---
            const handleAutoDefine = async () => {
                if (!newWord.trim()) { alert("Please enter a word or sentence."); return; }
                setIsAutoDefining(true);
                const bracketMatch = newWord.match(/\[(.*?)\]/);
                let prompt = "";
                let extractedWord = null;
                const sLang = activeDeck.sourceLang;
                const tLang = activeDeck.targetLang;

                if (bracketMatch) {
                    extractedWord = bracketMatch[1];
                    const sentence = newWord;
                    prompt = `Analyze the word "${extractedWord}" in the context of this sentence: "${sentence}".
                    The sentence is in ${sLang}. Translate "${extractedWord}" to ${tLang}.
                    Return the output EXACTLY in this format:
                    SPECIFIC: [The meaning that fits this specific context]
                    GENERAL: [1 or 2 other common meanings, comma separated]
                    Do not add any other text.`;
                } else {
                    prompt = `Translate the ${sLang} word "${newWord}" to ${tLang}. Provide ONLY the ${tLang} meaning(s), separated by commas. Keep it concise. No extra text.`;
                }

                try {
                    const result = await callGeminiAPI(prompt, userApiKey);
                    const text = result.trim();

                    // Parse Specific/General format
                    const specificMatch = text.match(/SPECIFIC:\s*(.*)/i);
                    const generalMatch = text.match(/GENERAL:\s*(.*)/i);

                    if (specificMatch) {
                        const specific = capitalizeFirst(specificMatch[1].trim());
                        const general = generalMatch ? capitalizeFirst(generalMatch[1].trim()) : "";

                        // Set hint for UI
                        setContextHint(specific);

                        // Set input value to clean meanings list
                        const combined = general ? `${specific}, ${general}` : specific;
                        setNewMeaning(combined);

                        if (extractedWord) { setNewWord(capitalizeFirst(extractedWord)); }
                    } else {
                        // Fallback normal translation
                        setNewMeaning(text);
                        setContextHint(null);
                        if (extractedWord) { setNewWord(capitalizeFirst(extractedWord)); }
                    }

                } catch (error) { alert("Error: " + error.message); }
                finally { setIsAutoDefining(false); }
            };

            const handleGenerateSentence = async (wordId, wordText, e, isRegenerate = false) => {
                if (e) e.stopPropagation();

                if (!isRegenerate) {
                    const wordObj = activeDeck.words.find(w => w.id === wordId);
                    if (wordObj && wordObj.examples && wordObj.examples.length > 0) return;
                }

                setGeneratingSentenceFor(wordId);
                const sLang = activeDeck.sourceLang;
                const tLang = activeDeck.targetLang;
                try {
                    const prompt = `Write a simple, clear ${sLang} sentence using the word "${wordText}". Then provide the ${tLang} translation in parenthesis. Format: "${sLang} sentence. (${tLang} translation.)"`;
                    const result = await callGeminiAPI(prompt, userApiKey);

                    setDecks(prevDecks => prevDecks.map(deck => {
                        if (deck.id === activeDeckId) {
                            return {
                                ...deck,
                                words: deck.words.map(w => {
                                    if (w.id === wordId) {
                                        const newExamples = [...(w.examples || []), result];
                                        if (newExamples.length > 5) {
                                            newExamples.shift();
                                        }
                                        return { ...w, examples: newExamples };
                                    }
                                    return w;
                                })
                            };
                        }
                        return deck;
                    }));

                    setActiveExampleIndices(prev => {
                        return { ...prev, [wordId]: undefined };
                    });

                } catch (error) { alert("Error: " + error.message); }
                finally { setGeneratingSentenceFor(null); }
            };

            // --- QUIZ LOGIC ---
            const generateQuestion = () => {
                const words = activeDeck.words;
                if (words.length < 4) return;
                const randomIndex = Math.floor(Math.random() * words.length);
                const targetWord = words[randomIndex];
                let distractors = words.filter(w => w.id !== targetWord.id);
                distractors = distractors.sort(() => 0.5 - Math.random()).slice(0, 3);
                const options = [...distractors, targetWord].sort(() => 0.5 - Math.random());
                setCurrentQuestion({ target: targetWord, options: options });
                setSelectedOption(null);
                setIsCorrect(null);
            };

            useEffect(() => {
                if (view === 'quiz') generateQuestion();
                else setStreak(0);
            }, [view, activeDeckId]);

            const handleAnswer = (option) => {
                if (selectedOption) return;
                setSelectedOption(option);
                if (option.id === currentQuestion.target.id) {
                    setIsCorrect(true);
                    setStreak(s => s + 1);
                    setTimeout(generateQuestion, 1500);
                } else {
                    setIsCorrect(false);
                    setStreak(0);
                }
            };

            // Helper to render card examples logic
            const renderCardExamples = (item) => {
                const examples = item.examples || [];
                const hasExamples = examples.length > 0;
                const currentIndex = activeExampleIndices[item.id] !== undefined
                    ? activeExampleIndices[item.id]
                    : examples.length - 1;

                const currentText = hasExamples ? examples[currentIndex] : null;

                return (
                    <div className="mt-4 pt-4 border-t border-gray-50 dark:border-gray-700">
                        {hasExamples ? (
                            <div>
                                <div
                                    className="mb-2 text-xs text-indigo-800 dark:text-indigo-200 bg-indigo-50 dark:bg-indigo-900/20 p-2 rounded cursor-text min-h-[3em] flex items-center"
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    {renderGeneratedSentence(item.id, currentText)}
                                </div>
                                <div className="flex justify-between items-center" onClick={(e) => e.stopPropagation()}>
                                    <div className="flex items-center gap-1">
                                        <button
                                            onClick={() => handlePrevExample(item.id, examples.length)}
                                            disabled={examples.length <= 1}
                                            className="p-1 text-gray-400 hover:text-indigo-600 disabled:opacity-30 disabled:hover:text-gray-400 transition-colors"
                                        >
                                            <ChevronLeftIcon />
                                        </button>
                                        <span className="text-[10px] font-mono text-gray-400 w-8 text-center select-none">
                                            {currentIndex + 1}/{examples.length}
                                        </span>
                                        <button
                                            onClick={() => handleNextExample(item.id, examples.length)}
                                            disabled={examples.length <= 1}
                                            className="p-1 text-gray-400 hover:text-indigo-600 disabled:opacity-30 disabled:hover:text-gray-400 transition-colors"
                                        >
                                            <ChevronRightIcon />
                                        </button>
                                    </div>

                                    <button
                                        onClick={(e) => handleGenerateSentence(item.id, item.word, e, true)}
                                        disabled={generatingSentenceFor === item.id}
                                        title="Regenerate Sentence"
                                        className="text-gray-400 hover:text-indigo-500 transition-colors p-1"
                                    >
                                        <div className={generatingSentenceFor === item.id ? "animate-spin" : ""}>
                                            <RefreshIcon />
                                        </div>
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <div className="flex justify-end">
                                <button
                                    onClick={(e) => handleGenerateSentence(item.id, item.word, e)}
                                    disabled={generatingSentenceFor === item.id}
                                    title="Generate Sentence"
                                    className="text-xs font-medium text-indigo-500 dark:text-indigo-400 hover:underline flex items-center gap-1 relative z-10"
                                >
                                    {generatingSentenceFor === item.id ? 'Generating...' : <><BulbIcon /> Example Sentence</>}
                                </button>
                            </div>
                        )}
                    </div>
                );
            };

            return (
                <div className="min-h-screen flex flex-col items-center py-8 px-4 max-w-2xl mx-auto w-full relative transition-colors duration-300">

                    {/* Header */}
                    <header className="w-full mb-6 bg-white dark:bg-gray-800 p-4 rounded-2xl card-shadow transition-colors duration-300">
                        <div className="flex justify-between items-center mb-4">
                            <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400">
                                VocabMaster
                            </h1>
                            <div className="flex items-center gap-2">
                                <button onClick={() => setDarkMode(!darkMode)} className="p-2 text-gray-400 dark:text-gray-300 hover:text-gray-600 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-700 rounded-full transition-colors">
                                    {darkMode ? <SunIcon /> : <MoonIcon />}
                                </button>
                                <button onClick={() => setShowSettings(true)} className="p-2 text-gray-400 dark:text-gray-300 hover:text-gray-600 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-700 rounded-full transition-colors">
                                    <SettingsIcon />
                                </button>
                            </div>
                        </div>

                        {/* Deck Selector & Tabs */}
                        <div className="flex flex-col gap-3">
                            <div className="relative z-20">
                                <button
                                    onClick={() => setShowDeckSelector(!showDeckSelector)}
                                    className="w-full flex justify-between items-center bg-gray-50 dark:bg-gray-700 p-3 rounded-xl border border-gray-200 dark:border-gray-600 text-sm font-semibold text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors"
                                >
                                    <div className="flex items-center gap-2">
                                        <GlobeIcon />
                                        <span>{activeDeck.sourceLang} &rarr; {activeDeck.targetLang}</span>
                                    </div>
                                    <ChevronDown />
                                </button>

                                {showDeckSelector && (
                                    <div className="absolute top-full mt-2 left-0 w-full bg-white dark:bg-gray-800 rounded-xl shadow-xl border border-gray-100 dark:border-gray-600 overflow-hidden animate-fade-in z-30">
                                        {decks.map(deck => (
                                            <button
                                                key={deck.id}
                                                onClick={() => switchDeck(deck.id)}
                                                className={`w-full text-left px-4 py-3 text-sm flex items-center justify-between hover:bg-gray-50 dark:hover:bg-gray-700 ${deck.id === activeDeckId ? 'text-blue-600 dark:text-blue-400 font-bold bg-blue-50 dark:bg-gray-700' : 'text-gray-600 dark:text-gray-300'}`}
                                            >
                                                {deck.sourceLang} &rarr; {deck.targetLang}
                                                {deck.id === activeDeckId && <span className="w-2 h-2 bg-blue-600 rounded-full"></span>}
                                            </button>
                                        ))}
                                        <div className="border-t border-gray-100 dark:border-gray-600">
                                            <button
                                                onClick={() => { setShowDeckModal(true); setShowDeckSelector(false); }}
                                                className="w-full text-left px-4 py-3 text-sm text-indigo-600 dark:text-indigo-400 font-bold hover:bg-gray-50 dark:hover:bg-gray-700 flex items-center gap-2"
                                            >
                                                <PlusIcon /> Add New Language Pair
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div className="flex bg-gray-100 dark:bg-gray-700 p-1 rounded-lg">
                                <button onClick={() => setView('list')} className={`flex-1 flex justify-center items-center gap-2 py-2 rounded-md transition-all text-xs font-bold ${view === 'list' || view === 'allWords' ? 'bg-white dark:bg-gray-600 text-blue-600 dark:text-blue-300 shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}>
                                    <ListIcon /> List
                                </button>
                                <button onClick={() => setView('quiz')} className={`flex-1 flex justify-center items-center gap-2 py-2 rounded-md transition-all text-xs font-bold ${view === 'quiz' ? 'bg-white dark:bg-gray-600 text-indigo-600 dark:text-indigo-300 shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}>
                                    <BrainIcon /> Quiz
                                </button>
                            </div>
                        </div>
                    </header>

                    {/* New Deck Modal */}
                    {showDeckModal && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-40 backdrop-blur-sm p-4 animate-fade-in">
                            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 w-full max-w-sm border dark:border-gray-700">
                                <h3 className="text-lg font-bold text-gray-800 dark:text-white mb-4">New Language Pair</h3>
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-xs font-bold text-gray-500 dark:text-gray-400 uppercase mb-1">I want to learn (Source)</label>
                                        <input
                                            type="text"
                                            value={newSourceLang}
                                            onChange={(e) => setNewSourceLang(e.target.value)}
                                            className="w-full p-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none text-sm dark:text-white"
                                            placeholder="e.g. Spanish"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-xs font-bold text-gray-500 dark:text-gray-400 uppercase mb-1">I speak (Target)</label>
                                        <input
                                            type="text"
                                            value={newTargetLang}
                                            onChange={(e) => setNewTargetLang(e.target.value)}
                                            className="w-full p-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none text-sm dark:text-white"
                                            placeholder="e.g. English"
                                        />
                                    </div>
                                    <div className="flex gap-2 justify-end mt-2">
                                        <button onClick={() => setShowDeckModal(false)} className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-lg text-sm">Cancel</button>
                                        <button onClick={handleCreateDeck} className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-700">Create Deck</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Settings Modal */}
                    {showSettings && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-40 backdrop-blur-sm p-4 animate-fade-in">
                            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 w-full max-w-sm border dark:border-gray-700">
                                <h3 className="text-lg font-bold text-gray-800 dark:text-white mb-4">Settings</h3>

                                {/* API Key Section */}
                                <div className="mb-6">
                                    <label className="block text-xs font-bold text-gray-700 dark:text-gray-300 uppercase mb-2">Gemini API Key</label>
                                    <input
                                        type="password"
                                        value={userApiKey}
                                        onChange={(e) => setUserApiKey(e.target.value)}
                                        className="w-full p-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none mb-4 text-sm dark:text-white"
                                        placeholder="AIzaSy..."
                                    />
                                </div>

                                {/* Data Backup Section */}
                                <div className="mb-6 pt-6 border-t border-gray-100 dark:border-gray-700">
                                    <h4 className="text-sm font-bold text-gray-800 dark:text-white mb-2">Data Backup</h4>
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mb-3">Export your decks to a file or restore from a backup.</p>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleExport}
                                            className="flex-1 flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 py-2 rounded-lg text-sm font-medium transition-colors"
                                        >
                                            <DownloadIcon /> Export
                                        </button>
                                        <label className="flex-1 flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 py-2 rounded-lg text-sm font-medium transition-colors cursor-pointer">
                                            <UploadIcon /> Import
                                            <input
                                                type="file"
                                                accept=".json"
                                                ref={fileInputRef}
                                                onChange={handleImport}
                                                className="hidden"
                                            />
                                        </label>
                                    </div>
                                </div>

                                <div className="flex justify-end gap-2 pt-2 border-t border-gray-100 dark:border-gray-700">
                                    <button
                                        onClick={() => setShowSettings(false)}
                                        className="px-4 py-2 text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg text-sm font-medium transition-colors"
                                    >
                                        Close
                                    </button>
                                    <button
                                        onClick={() => setShowSettings(false)}
                                        className="bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-indigo-700"
                                    >
                                        Save & Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Main Content */}
                    <main className="w-full">

                        {view === 'list' && (
                            <div className="animate-fade-in">
                                {/* Add Word Form */}
                                <form onSubmit={handleAddWord} className="bg-white dark:bg-gray-800 p-6 rounded-2xl card-shadow mb-6 border border-white dark:border-gray-700 relative overflow-hidden transition-colors duration-300">
                                    <div className="absolute top-0 right-0 p-4 opacity-10 pointer-events-none dark:opacity-5">
                                        <SparklesIcon />
                                    </div>
                                    <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-4">Add New Word</h2>
                                    <div className="space-y-4">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-400 dark:text-gray-500 uppercase tracking-wider mb-1">
                                                {activeDeck.sourceLang} <span className="font-normal normal-case text-gray-300 dark:text-gray-600 ml-1">(Word or [context] sentence)</span>
                                            </label>
                                            <input
                                                type="text"
                                                value={newWord}
                                                onChange={(e) => setNewWord(e.target.value)}
                                                className={`w-full p-3 bg-gray-50 dark:bg-gray-700 border rounded-lg focus:outline-none focus:ring-2 transition-all dark:text-white ${existingWordMatch ? 'border-yellow-400 focus:ring-yellow-400 dark:border-yellow-500' : 'border-gray-200 dark:border-gray-600 focus:ring-blue-500'}`}
                                                placeholder="e.g. serendipity"
                                            />
                                            {existingWordMatch && (
                                                <div className="mt-2 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 text-yellow-800 dark:text-yellow-200 p-3 rounded-lg text-sm flex flex-col animate-fade-in">
                                                    <span className="font-bold text-xs uppercase tracking-wider text-yellow-600 dark:text-yellow-400 mb-1">Already in deck!</span>
                                                    <div className="font-medium">
                                                        <span className="text-gray-600 dark:text-gray-400">Meaning:</span> {renderMeaningHTML(existingWordMatch.meaning, false)}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                        <div className="relative">
                                            <label className="block text-xs font-medium text-gray-400 dark:text-gray-500 uppercase tracking-wider mb-1 flex justify-between">
                                                <span>{activeDeck.targetLang} Meaning</span>
                                                <button
                                                    type="button"
                                                    onClick={handleAutoDefine}
                                                    disabled={isAutoDefining || !newWord}
                                                    className="text-indigo-500 dark:text-indigo-400 hover:text-indigo-700 dark:hover:text-indigo-300 text-xs font-bold flex items-center gap-1 disabled:opacity-50"
                                                >
                                                    {isAutoDefining ? <span className="loading-dots">Analyzing</span> : <><SparklesIcon /> AI Auto-Fill</>}
                                                </button>
                                            </label>
                                            <input
                                                type="text"
                                                value={newMeaning}
                                                onChange={(e) => setNewMeaning(e.target.value)}
                                                className="w-full p-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all pr-10 dark:text-white"
                                                placeholder="Meaning..."
                                            />
                                            {contextHint && (
                                                <div className="flex items-center gap-1.5 mt-2 text-xs font-medium text-indigo-600 dark:text-indigo-400 animate-fade-in">
                                                    <InfoIcon />
                                                    <span>Specific meaning in this context: {contextHint}</span>
                                                </div>
                                            )}
                                        </div>
                                        <button
                                            type="submit"
                                            disabled={!newWord || !newMeaning}
                                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 rounded-lg transition-colors flex justify-center items-center gap-2 disabled:opacity-50"
                                        >
                                            <PlusIcon /> Add to List
                                        </button>
                                    </div>
                                </form>

                                {/* Limited List (Last 5) */}
                                <div className="space-y-3">
                                    <div className="flex justify-between items-end px-1 mb-1">
                                        <h3 className="text-sm font-semibold text-gray-500 dark:text-gray-400 uppercase">Your Words ({activeDeck.words.length})</h3>
                                        {activeDeck.words.length > 5 && (
                                            <button
                                                onClick={() => setView('allWords')}
                                                className="text-xs font-bold text-indigo-600 dark:text-indigo-400 hover:underline flex items-center gap-1"
                                            >
                                                See All <GridIcon />
                                            </button>
                                        )}
                                    </div>

                                    {activeDeck.words.length === 0 ? (
                                        <div className="text-center py-10 bg-white dark:bg-gray-800 rounded-2xl border-2 border-dashed border-gray-200 dark:border-gray-700">
                                            <p className="text-gray-400 dark:text-gray-500">No words yet in this deck.</p>
                                        </div>
                                    ) : (
                                        // SHOW ONLY LAST 5 WORDS
                                        activeDeck.words.slice().reverse().slice(0, 5).map(item => (
                                            <div key={item.id} className="bg-white dark:bg-gray-800 p-4 rounded-xl border border-gray-100 dark:border-gray-700 shadow-sm hover:shadow-md transition-all">
                                                <div className="flex justify-between items-start">
                                                    <div>
                                                        <div className="flex items-center gap-2">
                                                            <p className="text-lg font-bold text-gray-800 dark:text-white">{item.word}</p>
                                                        </div>
                                                        <p className="text-gray-500 dark:text-gray-400 text-sm">
                                                            {renderMeaningHTML(item.meaning, false)}
                                                        </p>
                                                    </div>
                                                    <button
                                                        onClick={() => handleDelete(item.id)}
                                                        className="text-gray-300 hover:text-red-500 p-2"
                                                    >
                                                        <TrashIcon />
                                                    </button>
                                                </div>

                                                {/* Replaced old sentence logic with new robust card component */}
                                                {renderCardExamples(item)}
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        )}

                        {/* ALL WORDS VIEW (GRID + SHUFFLE + STUDY MODE) */}
                        {view === 'allWords' && (
                            <div className="animate-fade-in">
                                <div className="mb-6">
                                    <h2 className="text-2xl font-bold text-gray-800 dark:text-white text-center mb-6">
                                        All Cards ({shuffledWords.length})
                                    </h2>

                                    <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
                                        <button
                                            onClick={() => setView('list')}
                                            className="text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-white flex items-center gap-1 font-medium text-sm transition-colors self-start sm:self-auto"
                                        >
                                            <ArrowLeftIcon /> Back to Add
                                        </button>

                                        <div className="flex gap-2 w-full sm:w-auto justify-center sm:justify-end">
                                            <button
                                                onClick={toggleStudyMode}
                                                className={`px-3 py-2 rounded-lg text-sm font-semibold transition-colors flex items-center gap-2 ${isStudyMode ? 'bg-indigo-600 text-white shadow-lg' : 'bg-white dark:bg-gray-700 text-gray-600 dark:text-gray-200 border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-600'}`}
                                            >
                                                {isStudyMode ? <EyeIcon /> : <EyeOffIcon />}
                                                {isStudyMode ? 'Study Mode ON' : 'Study Mode'}
                                            </button>
                                            <button
                                                onClick={handleShuffle}
                                                className="bg-indigo-100 dark:bg-indigo-900/50 text-indigo-700 dark:text-indigo-300 px-3 py-2 rounded-lg text-sm font-semibold hover:bg-indigo-200 dark:hover:bg-indigo-900 transition-colors flex items-center gap-2"
                                            >
                                                <ShuffleIcon /> Shuffle
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    {shuffledWords.map(item => (
                                        <div
                                            key={item.id}
                                            onClick={() => toggleReveal(item.id)}
                                            className={`bg-white dark:bg-gray-800 p-5 rounded-xl border shadow-sm transition-all flex flex-col justify-between min-h-[140px] relative ${isStudyMode ? 'cursor-pointer hover:border-indigo-300 dark:hover:border-indigo-600' : 'hover:shadow-md'} border-gray-100 dark:border-gray-700`}
                                        >
                                            <div>
                                                <div className="flex justify-between items-start mb-3">
                                                    <div className="flex items-center gap-2">
                                                        <h3 className="text-xl font-bold text-gray-800 dark:text-white break-words">{item.word}</h3>
                                                    </div>
                                                    {!isStudyMode && (
                                                        <button
                                                            onClick={(e) => { e.stopPropagation(); handleDelete(item.id); }}
                                                            className="text-gray-300 hover:text-red-500 -mt-1 -mr-1"
                                                        >
                                                            <TrashIcon />
                                                        </button>
                                                    )}
                                                </div>

                                                <div className="text-gray-600 dark:text-gray-300 min-h-[1.5em]">
                                                    {isStudyMode && !revealedCards[item.id] ? (
                                                        <div className="flex items-center gap-2 text-gray-400 dark:text-gray-500 text-sm italic select-none">
                                                            <EyeOffIcon /> Tap to show meaning
                                                        </div>
                                                    ) : (
                                                        renderMeaningHTML(item.meaning, false)
                                                    )}
                                                </div>
                                            </div>

                                            {/* Updated Card Examples Logic */}
                                            {renderCardExamples(item)}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {view === 'quiz' && (
                            <div className="animate-fade-in w-full">
                                {activeDeck.words.length < 4 ? (
                                    <div className="bg-yellow-50 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 p-6 rounded-2xl text-center border border-yellow-200 dark:border-yellow-700">
                                        <p>You need at least 4 words in this deck to start a quiz. ({activeDeck.words.length}/4)</p>
                                        <button onClick={() => setView('list')} className="mt-4 text-blue-600 dark:text-blue-400 font-bold hover:underline">Return to List</button>
                                    </div>
                                ) : (
                                    currentQuestion && (
                                        <div className="bg-white dark:bg-gray-800 rounded-3xl card-shadow overflow-hidden transition-colors duration-300">
                                            <div className="bg-gradient-to-br from-indigo-600 to-purple-700 dark:from-indigo-800 dark:to-purple-900 p-8 text-center text-white relative">
                                                <div className="absolute top-4 right-4 bg-white/20 backdrop-blur-sm px-3 py-1 rounded-full text-xs font-medium">
                                                    Streak: {streak} 
                                                </div>
                                                <p className="text-indigo-200 text-sm font-medium uppercase tracking-widest mb-2">What is the meaning?</p>
                                                <h2 className="text-4xl font-extrabold drop-shadow-md">{currentQuestion.target.word}</h2>
                                            </div>

                                            <div className="p-6 space-y-3">
                                                {currentQuestion.options.map((option) => {
                                                    let btnClass = "w-full text-left p-4 rounded-xl border-2 font-medium transition-all duration-200 ";
                                                    if (selectedOption) {
                                                        if (option.id === currentQuestion.target.id) btnClass += "bg-green-100 dark:bg-green-900/30 border-green-500 text-green-700 dark:text-green-400";
                                                        else if (option.id === selectedOption.id) btnClass += "bg-red-50 dark:bg-red-900/30 border-red-500 text-red-700 dark:text-red-400";
                                                        else btnClass += "bg-gray-50 dark:bg-gray-700 border-gray-100 dark:border-gray-600 text-gray-400 dark:text-gray-500 opacity-50";
                                                    } else {
                                                        btnClass += "bg-white dark:bg-gray-700 border-gray-100 dark:border-gray-600 text-gray-700 dark:text-gray-200 hover:border-indigo-300 dark:hover:border-indigo-500 hover:bg-indigo-50 dark:hover:bg-gray-600 shadow-sm";
                                                    }
                                                    return (
                                                        <button key={option.id} onClick={() => handleAnswer(option)} disabled={selectedOption !== null} className={btnClass}>
                                                            {renderMeaningHTML(option.meaning, true)}
                                                        </button>
                                                    );
                                                })}
                                            </div>

                                            <div className="px-6 pb-6 min-h-[4rem] flex items-center justify-center gap-4">
                                                {selectedOption && isCorrect && (
                                                    <span className="text-green-600 dark:text-green-400 font-bold animate-bounce">Correct! </span>
                                                )}
                                                {selectedOption && !isCorrect && (
                                                    <>
                                                        <span className="text-red-500 dark:text-red-400 font-bold">Incorrect!</span>
                                                        <button
                                                            onClick={generateQuestion}
                                                            className="px-4 py-2 bg-indigo-100 dark:bg-indigo-900/50 text-indigo-700 dark:text-indigo-300 rounded-lg text-sm font-semibold hover:bg-indigo-200 dark:hover:bg-indigo-900 transition-colors"
                                                        >
                                                            Next Question &rarr;
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    )
                                )}
                            </div>
                        )}
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
